---
title: Config Server for Pivotal Cloud Foundry
---

## <a id="overview"></a>Overview ##

Config Server for Pivotal Cloud Foundry is an externalized application configuration service. With the Config Server you have a central place to manage external properties for applications across all environments. The concepts on both client and server map identically to the Spring Environment and PropertySource abstractions, so they fit very well with Spring applications, but can be used with any application running in any language. As an application moves through the deployment pipeline from dev to test and into production you can manage the configuration between those environments and be certain that applications have everything they need to run when they migrate. The default implementation of the server storage backend uses git so it easily supports labelled versions of configuration environments, as well as being accessible to a wide range of tooling for managing the content. Subversion and classpath-local configurations are also supported. 

## <a id="config-server"></a>The Config Server ##

A Config Server serves properties in either Java Properties format or Yaml format under the following paths:

```
/{application}/{profile}[/{label}]
/{application}-{profile}.yml
/{label}/{application}-{profile}.yml
/{application}-{profile}.properties
/{label}/{application}-{profile}.properties
```

A Configuration path contains an Application, a Profile, and optionally a Label. 

## <a id="config-sources"></a>Configuration Sources ##

Configurations served by the Config Server ultimately come from a Configration Source, which can be a Git repository, SVN repository, or a local filesystem path. A Configuration Source can contain one or more configuration files for one or more applications. Configuration files can be in Java Properties or Yaml format. A configuration file applies to an Application, and can optionally apply to a specific Profile and/or Label. 

Here's an example Git repository that can be used as a Configuration Source:

```
master
------
https://github.com/myorg/configurations
|- myapp.yml
|- myapp-development.yml
|- myapp-production.yml

tag v1.0.0
----------
https://github.com/myorg/configurations
|- myapp.yml
|- myapp-development.yml
|- myapp-production.yml
```

In this example, the Configuration Source defines configurations for the application named ```myapp```. The server will serve different properties for myapp depending on the values of ```{profile}``` and ```{label}``` in the request path. An example response can be found [here](#example-request).

If the ```{profile}``` is neither ```development``` or ```production```, the properties in myapp.yml will be returned. If the ```{profile}``` is ```production```, the properties in both myapp-production.yml and myapp.yml will be returned.  

If the request contains a ```{label}``` of ```v1.0.0```, properties from that tag will be served. If ```{label}``` is not present in the request, properties from the default label will be served. ```{label}``` can be a git commit hash as well as a tag or branch name. The default label for git repositories is "master", but this can be configured in the next section.

## <a id="create-config-server"></a>Creating a Config Server Service ##

1. Log into the Apps Manager as a Space Developer.

1. Select the Config Server for Pivotal Cloud Foundry from the Marketplace.
   <%= image_tag("config-server/1_marketplace.png") %>

1. Select the desired plan for the new service.
   <%= image_tag("config-server/2_select_plan.png") %>

1. Provide a name for the new Config Server service (e.g. config-server) and click the Add button.
   <%= image_tag("config-server/3_instance_name.png") %>

1. Select the Manage link on the new service instance.
   <%= image_tag("config-server/4_service_successfully_added.png") %>

1. Select a Confguration Source, enter a URI, and optionally a branch, which will be the default "label" if no label is given in the request. Hit the Submit button.
   <%= image_tag("config-server/dashboard.png") %>

The Config Service is now ready to be used.

## <a id="config-clients"></a>Configuration Clients ##

A Configuration Client can be written in any language; the interface for retrieving configuration is HTTP, and the endpoints are protected with HTTP Basic authentication. To get a base URI and credentials that can be used to access the configuration server, a Cloud Foundry Application needs to bind to a Service Instance of the Configuration Server, eg. ```cf bind-service myapp config-server```. When an application is bound to the service instance, the application's VCAP_SERVICES environment variable will contain an entry under the key ```p-config-server```:

```
{
  "p-config-server": [
    {
      "name": "config-server",
      "label": "p-config-server",
      "tags": [
        "configuration",
        "spring-cloud"
      ],
      "plan": "standard",
      "credentials": {
        "uri": "http://user:password@configserver.mydomain.com"
      }
    }
  ],
  "some-other-service": [{"...":"..."}]
}
```

Here's an example request/response that uses the uri in the credentials object, against the example Git repository outlined in the previous section:

<span id="example-request"></span>

```
$ curl http://user:password@configserver.mydomain.com/myapp/production

{
  "name": "myapp",
  "profiles": [
    "production"
  ],
  "label": "master",
  "propertySources": [
    {
      "name": "https://github.com/myorg/configurations/myapp-production.yml",
      "source": {
        "hello.message": "Hello Production!"
      }
    },
    {
      "name": "https://github.com/myorg/configurations/myapp.yml",
      "source": {
        "hello.message": "Hello Default!"
      }
    }
  ]
}
```

It's up to the client application to interpret how a response containing multiple values for the same property should be used, like in the response above. The intent is that the first value in the list should take higher precendence, so in the above example, the client application should use "Hello Production!" as the value for the property ```hello.message```. Spring applications will do this for you automatically.

### <a id="spring-config-clients"></a>Spring Configuration Clients ###

A Spring application can use a Configuration Server as a Property Source. Properties from a Config Server will override those defined locally (eg. via an application.yml in the classpath). The application requests properties from the config server using the path ```/{application}/{profile}/[{label}]```, and values for these 3 parameters are derived from the following properties:

* application - ```spring.cloud.config.name``` or ```spring.application.name```
* profile - ```spring.cloud.config.env``` or ```spring.profiles.active```
* label - ```spring.cloud.config.label``` or if not defined, the Config Server's default label is used

These values can be specified in the application.yml or application.properties on the classpath, via system property (-Dspring.profiles.active=production), or more commonly in Cloud Foundry, via environment variable eg: ```cf set-env myapp SPRING_PROFILES_ACTIVE production```

In the request/response example above, the Spring application would load the two property sources with a higher precendence than other property sources. That means properties in https://github.com/myorg/configurations/myapp-production.yml would have a higher precendence than properties in https://github.com/myorg/configurations/myapp.yml, which would have a higher precendence than the application's other property sources (eg classpath:application.yml).

To use the configuration server service, the following Spring Boot application, **bound to a Config Server service instance**, would suffice:

*pom.xml*

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>

	<groupId>com.mydomain</groupId>
	<artifactId>myapp</artifactId>
	<version>0.0.1-SNAPSHOT</version>

	<parent>
		<groupId>org.springframework.cloud</groupId>
		<artifactId>spring-cloud-starter-parent</artifactId>
		<version>1.0.2.RELEASE</version>
	</parent>

	<dependencies>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-actuator</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-starter-config</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-pivotal-cloudfoundry-connector</artifactId>
			<version>1.0.0.BUILD-SNAPSHOT</version>
		</dependency>
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-pivotal-spring-connector</artifactId>
			<version>1.0.0.BUILD-SNAPSHOT</version>
		</dependency>
	</dependencies>

	<build>
		<plugins>
			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
			</plugin>
		</plugins>
	</build>
	
	<repositories>
		<repository>
			<id>spring-snapshots</id>
			<url>https://repo.spring.io/libs-snapshot</url>
			<snapshots>
				<enabled>true</enabled>
			</snapshots>
		</repository>
	</repositories>


</project>


```

*MyApp.java*

```java
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@SpringBootApplication
@RestController
public class MyApp {

    public static void main(String[] args) {
       SpringApplication.run(MyApp.class, args);
    }
    
    @Value("${hello.message}")
    private String helloMessage;
    
    @RequestMapping("/")
    public String hello() {
        return helloMessage;
    }
    
}

```

*src/main/resources/application.yml*

```yml
spring.application.name: myapp
```
